#include <cstdio>
#include <SDL2/SDL.h>
#include "hidmanager.h"
#include "eventmanager.h"

namespace ice
{

namespace events
{

bool EventManager::Init()
{
    if (SDL_InitSubSystem(SDL_INIT_EVENTS) == 0 || xboxControllerManager_.Init()) return true;

    printf("Couldn't init event manager: %s\n", SDL_GetError());
    return false;
}

EventManager::~EventManager()
{
    SDL_QuitSubSystem(SDL_INIT_EVENTS);
    xboxControllerManager_.ShutDown();
}

void EventManager::Poll()
{
    SDL_Event event;
    while (SDL_PollEvent(&event))
    {
        switch(event.type)
        {
        case SDL_QUIT:
            shouldQuit_ = true;
            return;
        case SDL_KEYDOWN:
            if (event.key.keysym.sym == SDLK_ESCAPE)
            {
                shouldQuit_ = true;
                return;
            }
            break;
        default:
            break;
        }
    }

    xboxControllerManager_.Poll(rawState_);
    AdjustPlayerState(PlayerID::e1);
    AdjustPlayerState(PlayerID::e2);
}

void EventManager::AdjustPlayerState(PlayerID id)
{
    // The connection status is fine to poll for every frame.
    adjustedState_.connectionState_ = rawState_.connectionState_;
    PlayerState& state = adjustedState_.playerStates_[(size_t)id];
    state.previousMetaState_ = state.currentMetaState_;
    state.previousMovementState_ = state.previousMovementState_;

    // If an event is down, increment the held counter for it
    // If it has been down for 255 frames, let it stay at 255.
    // If an event is not held, reset its frame counter.
    // If an has been held for n frames, modify the adjusted state and reset its held count

    
}

bool EventManager::ShouldQuit()
{
    return shouldQuit_;
}

} // namespace events

} // namespace ice
